---
title: "cindex"
format: html
editor: visual
---

The `echo: false` option disables the printing of code (only output is displayed).

```{r}
library(data.table)
library(mlr3)
library(mlr3learners)
library(mlr3measures)
library(ggplot2)
library(pec)
library(survival)
library(dplyr)
library(randomForestSRC)
library(survAUC) # concordance index
```

```{r}
sps <- fread("../data/sps.csv")

# Drop unwanted columns
drop_cols <- c(
  # we want to drop these
  "dbsource", "formulary_drug_cd_list", "admission_location", "admittime", "dischtime",
  "edregtime", "edouttime", "diagnosis", "latest_gcs_time", "comorbidities", "proc.icd9_list",
  
  # dropping but not sure how to handle yet
  "gcs_total", "gcs_verbal", "gcs_motor", "gcs_eye", "language", "drug.Miscellaneous", "diag.Missing"
)

# dropping those columns
sps[, (drop_cols) := NULL]

# drop patients with missing age (until we figure out what imputation we're doing)
sps <- sps[!is.na(age.at.admit)]


# One-hot encode
cat_vars <- c("gender", "admission_type", "insurance", "religion", "marital_status", "ethnicity", "discharge_location", "intervention.group")



# One-hot encode categorical variables
mm <- model.matrix(~ . - 1, data = sps[, ..cat_vars])

# Remove duplicate column names if any
mm <- mm[, !duplicated(colnames(mm))]

# Combine with rest of dataset
sps <- cbind(sps[, !cat_vars, with = FALSE], as.data.table(mm))

# FIX HERE
#sps <- as.data.table(model.matrix(~ . - 1, data = sps, subset = cat_vars))[, .SD, .SDcols = !duplicated(names(.SD))]

sps <- cbind(sps, sps[, !names(sps) %in% cat_vars, with = FALSE])

# Ethnicity merging (logical -> numeric)
sps[, ethnicityWHITE := +(`ethnicityWHITE` + `ethnicityWHITE - BRAZILIAN` + `ethnicityWHITE - OTHER EUROPEAN` + `ethnicityWHITE - RUSSIAN` + `ethnicityMIDDLE EASTERN` > 0)]

sps[, ethnicityBLACK := +(`ethnicityBLACK/AFRICAN AMERICAN` + `ethnicityBLACK/CAPE VERDEAN` + `ethnicityBLACK/HAITIAN` > 0)]

sps[, ethnicityHISPANICLATINO := +(`ethnicityHISPANIC OR LATINO` + `ethnicityHISPANIC/LATINO - COLOMBIAN` + `ethnicityHISPANIC/LATINO - DOMINICAN` + `ethnicityHISPANIC/LATINO - PUERTO RICAN` > 0)]

sps[, ethnicityASIAN := +(rowSums(.SD) > 0), .SDcols = patterns("ethnicityASIAN")]

sps[, ethnicityOTHER := +(`ethnicityMULTI RACE ETHNICITY` + ethnicityOTHER > 0)]

sps[, ethnicityUNKNOWN := +(`ethnicityPATIENT DECLINED TO ANSWER` + `ethnicityUNABLE TO OBTAIN` + `ethnicityUNKNOWN/NOT SPECIFIED` > 0)]

# Drop raw ethnicity columns
sps <- sps[, !grepl("ethnicity", names(sps)) | names(sps) %in% c("ethnicityWHITE", "ethnicityBLACK", "ethnicityHISPANIC_LATINO", "ethnicityASIAN", "ethnicityOTHER", "ethnicityUNKNOWN"), with = FALSE]

# Filter out zero survival
sps <- sps[survival_days > 0]

# Binary target
sps[, survived_90 := survival_days > 90]

# Fill NAs
sps[is.na(sps)] <- 0

# Remove ID columns
X <- sps[, !c("subject_id", "survival_days", "survived_90", "event"), with = FALSE]
y <- sps[, .(time = survival_days, status = as.integer(event))]

# Combine for mlr3 task
data <- cbind(X, y)


```

```{r}
#mutate(ethnicity = case_when(
#    str_detect(ethnicity, regex("ASIAN", ignore_case = TRUE)) ~ "Asian",
#    str_detect(ethnicity, regex("WHITE|MIDDLE", ignore_case = TRUE)) ~ "White",
#    str_detect(ethnicity, regex("BLACK", ignore_case = TRUE)) ~ "Black or African #American",
#    str_detect(ethnicity, regex("OTHER|PATIENT|UNABLE|UNKNOWN", ignore_case = TRUE#)) ~ "Unknown",
#    str_detect(ethnicity, regex("AMERICAN", ignore_case = TRUE)) ~ "American Indian #or Alaska Native",
#    str_detect(ethnicity, regex("HISPANIC", ignore_case = TRUE)) ~ "Hispanic#/Latino",
#    str_detect(ethnicity, regex("MULTI", ignore_case = TRUE)) ~ "More than one #race",
#    TRUE ~ "Unknown"
#  ))
```

```{r}

sps <- sps[, !duplicated(names(sps)), with = FALSE]

# Prepare survival object
sps <- sps %>% dplyr::filter(!is.na(event), !is.na(survival_days))

# Train/test split
set.seed(7)
train_idx <- sample(seq_len(nrow(sps)), size = 0.8 * nrow(sps))
train_data <- sps[train_idx, ]
test_data <- sps[-train_idx, ]

# fit random survival forest
rsf_model <- rfsrc(Surv(survival_days, event) ~ ., data = train_data %>% select(-subject_id, -survived_90))

# fit gradient boosting model (Cox PH boosting)
library(gbm)
gbm_model <- gbm(Surv(survival_days, event) ~ ., 
                 data = train_data %>% select(-subject_id, -survived_90),
                 distribution = "coxph",
                 n.trees = 100)

rsf_pred <- predict(rsf_model, newdata = test_data)

gbm_pred <- predict(gbm_model, newdata = test_data %>% select(-subject_id, -survived_90), n.trees = 100)


```

```{r}
y_test <- Surv(test_data$survival_days, test_data$event)

# risk score supposedly can be approximated as 1 - predicted survival probability at a fixed time (e.g., median), or use predicted mortality (1 - survival) at last time point

# risk score: 1 - survival probability at max time point predicted
risk_scores <- 1 - rsf_pred$survival[, ncol(rsf_pred$survival)]

rsf_pred <- predict(rsf_model, newdata = test_data)
rsf_cindex <- randomForestSRC::get.cindex(time = test_data$survival_days,
                               censoring = test_data$event,
                               predicted = rsf_pred$predicted)
print(paste("RSF C-index:", round(rsf_cindex, 3)))


```

```{r}
gbm_concordance <- concordance(y_test ~ gbm_pred)
print(paste("GBM C-index:", round(gbm_concordance$concordance, 3)))
```

```{r}
time_points <- c(90, 360, 720, 1460)

get_surv_probs <- function(surv_row, time_interest, time_points) {
  sapply(time_points, function(t) {
    idx <- max(which(time_interest <= t))
    surv_row[idx]
  })
}

# printing survival probabilities for first 5 test patients
for (i in 1:5) {
  surv_probs <- get_surv_probs(rsf_pred$survival[i, ], rsf_pred$time.interest, time_points)
  cat(sprintf("Patient %d survival probabilities:\n", i))
  for (j in seq_along(time_points)) {
    cat(sprintf("  P(survival > %d days) = %.3f\n", time_points[j], surv_probs[j]))
  }
}
```
